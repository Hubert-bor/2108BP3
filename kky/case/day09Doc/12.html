<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style>
			pre{
				font-size: 20px;
			}
		</style>
	</head>
	<body>
		<pre>
	Node.js模块系统
为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。
模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。
换言之，一个 Node.js 文件就是一个模块.
代码 require('./he') 引入了当前目录下的 he.js 文件（./ 为当前目录，node.js 默认后缀为 js）。
Node.js 提供了 exports 和 require 两个对象，
其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，
即所获取模块的 exports 对象。
he.js 通过 exports 对象把 say作为模块的访问接口，
exports.say = function() {
  console.log('Hello');
}
通过 require('./he') 加载这个模块，
然后就可以直接访 问 he.js 中 exports 对象的成员函数了.
var obj=require("./he");
obj.say();
----------------------------
模块接口的唯一变化是使用 module.exports=People;
代替了exports.say = function(){}。 
在外部引用该模块时，其接口对象就是要输出的 People 对象本身，
而不是原先的 exports。
exports 与 module.exports
为了方便，Node为每个模块提供一个exports变量，
指向module.exports。这等同在每个模块头部，有一行这样的命令。
var exports = module.exports;
于是我们可以直接在 exports 对象上添加方法，
表示对外输出的接口，如同在module.exports上添加一样。
注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。
------------------------------------------------
module.exports与exports的区别
每一个node.js执行文件，都自动创建一个module对象，
同时，module对象会创建一个叫exports的属性，初始化的值是 {}
 module.exports = {};
Node.js为了方便地导出功能函数，node.js会自动地实现以下这个语句

foo.js
----------------------------
 exports.a = function(){
 console.log('a')
 }
 exports.a = 1 
-----------------------------
test.js
----------------------------
 var x = require('./foo');
 console.log(x.a);
exports是引用 module.exports的值。
module.exports 被改变的时候，exports不会被改变，而模块导出的时候，
真正导出的执行是module.exports，而不是exports
再看看下面例子
foo.js
------------------------------------
 exports.a = function(){
  console.log('a')
 }
 module.exports = {a: 2}
 exports.a = 1 
------------------------------------
test.js
------------------------------------
var x = require('./foo');

console.log(x.a)
result:
------------------------------------
 2
exports在module.exports 被改变后，失效。
		</pre>
	</body>
</html>
